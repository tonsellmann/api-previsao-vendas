# -*- coding: utf-8 -*-
"""previsor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sgTA0spowr93d7OoT_wqHnQG2xM1HCDP
"""

# previsor.py

import pandas as pd
import statsmodels.api as sm
import numpy as np
import os

def analisar_e_prever_vendas(loja_desejada, mes_desejado, ano_desejado):
    """
    Função-núcleo que executa a previsão e retorna os resultados como um dicionário.
    Esta é a nossa "biblioteca" de previsão.
    """
    arquivo_csv = 'vendas.csv'
    if not os.path.exists(arquivo_csv):
        return {"erro": f"Arquivo '{arquivo_csv}' não encontrado."}

    df = pd.read_csv(arquivo_csv, delimiter=';')
    df['DATA'] = pd.to_datetime(df['ANO'].astype(str) + '-' + df['MES'].astype(str) + '-01')
    df = df.set_index('DATA')
    df_loja = df[df['LOJNUMERO'] == loja_desejada].copy().sort_index()

    if df_loja.empty:
        return {"erro": f"Loja {loja_desejada} não encontrada."}

    # Remove o último mês para evitar dados parciais
    df_loja_treino = df_loja.iloc[:-1]

    if len(df_loja_treino) < 12:
        return {"erro": "Dados insuficientes para um treinamento confiável após remoção do último mês."}

    # Lógica de previsão
    df_loja_treino['QUANTIDADE_LOG'] = np.log1p(df_loja_treino['QUANTIDADE'])
    df_loja_treino['SOMA_LOG'] = np.log1p(df_loja_treino['SOMA'])

    try:
        modelo_quantidade = sm.tsa.SARIMAX(df_loja_treino['QUANTIDADE_LOG'], order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)).fit(disp=False)
        modelo_soma = sm.tsa.SARIMAX(df_loja_treino['SOMA_LOG'], order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)).fit(disp=False)
    except Exception as e:
        return {"erro": f"Falha ao treinar o modelo: {e}"}

    data_previsao = pd.to_datetime(f'{ano_desejado}-{mes_desejado}-01')
    pred_qtd_log = modelo_quantidade.get_prediction(start=data_previsao, end=data_previsao)
    pred_soma_log = modelo_soma.get_prediction(start=data_previsao, end=data_previsao)

    valor_previsto_qtd = round(np.expm1(pred_qtd_log.predicted_mean.iloc[0]))
    valor_previsto_soma = round(np.expm1(pred_soma_log.predicted_mean.iloc[0]), 2)

    # Garantia de resultados positivos
    valor_previsto_qtd = max(0, valor_previsto_qtd)
    valor_previsto_soma = max(0, valor_previsto_soma)

    # Retorna um dicionário com os resultados
    return {
        "loja_consultada": loja_desejada,
        "previsao_para_data": f"{mes_desejado:02d}/{ano_desejado}",
        "previsao_quantidade": int(valor_previsto_qtd),
        "previsao_valor_vendas": float(valor_previsto_soma),
        "status": "sucesso"
    }